/* @flow */

// ? To regenerate this file (i.e. if you changed it and want your changes to
// ? be permanent), call `npm run regenerate` afterwards

// ! Be sure that tasks expected to run on npm install (marked @dependent) have
// ! all required packages listed under "dependencies" instead of
// ! "devDependencies" in this project's package.json

import { readFile } from 'fs'
import { promisify } from 'util'
import gulp from 'gulp'
import tap from 'gulp-tap'
import del from 'del'
import log from 'fancy-log'
import parseGitIgnore from 'parse-gitignore'
import { transformSync as babel } from '@babel/core'
import { parse as parsePath, relative as relPath } from 'path'
import term from 'inquirer'
import replaceInFile from 'replace-in-file'
import sh from 'shelljs'
import chalk from 'chalk'

require('dotenv').config();

const {
    BUNDLE_ANALYZE
} = process.env;

// ? Add any sanity checks/sentinels to this function body
// ! The existence of any new constants added to dist.env should be checked here
const sanityCheck = () => {
    if(typeof BUNDLE_ANALYZE !== 'string')
        throw new TypeError('BUNDLE_ANALYZE is improperly defined. Did you copy dist.env -> .env ?');
};

sh.config.silent = true;
sh.config.fatal = true;

const paths = {};

paths.flowTyped = 'flow-typed';
paths.flowTypedGitIgnore = `${paths.flowTyped}/.gitignore`;
paths.build = `build`;
paths.buildGitIgnore = `${paths.build}/.gitignore`;
paths.configs = 'config';
paths.packageJson = 'package.json';
paths.launchJson = '.vscode/launch.json';
paths.launchJsonDist = '.vscode/launch.dist.json';
paths.env = '.env';
paths.envDist = 'dist.env';
paths.gitProjectDir = '.git';
paths.gitIgnore = '.gitignore';
paths.packageLockJson = 'package-lock.json';

paths.regenTargets = [
    `${paths.configs}/*.js`
];

const CLI_BANNER = `/**
* !!! DO NOT EDIT THIS FILE DIRECTLY !!!
* ! This file has been generated automatically. See the config/*.js version of
* ! this file to make permanent modifications!
*/\n\n`;

const readFileAsync = promisify(readFile);

// * CLEANTYPES

const cleanTypes = async () => {
    sanityCheck();

    const targets = parseGitIgnore(await readFileAsync(paths.flowTypedGitIgnore));

    log(`Deletion targets @ ${paths.flowTyped}/: "${targets.join('" "')}"`);
    del(targets, { cwd: paths.flowTyped });
};

cleanTypes.description = `Resets the ${paths.flowTyped} directory to a pristine state`;

// * REGENERATE

// ? If you change this function, run `npm run regenerate` twice: once to
// ? compile this new function and once again to compile itself with the newly
// ? compiled logic. If there is an error that prevents regeneration, you can
// ? run `npm run generate` then `npm run regenerate` instead.
const regenerate = () => {
    sanityCheck();

    log(`Regenerating targets: "${paths.regenTargets.join('" "')}"`);

    process.env.BABEL_ENV = 'generator';

    return gulp.src(paths.regenTargets)
               .pipe(tap(file => file.contents = Buffer.from(CLI_BANNER + babel(file.contents.toString(), {
                   sourceFileName: relPath(__dirname, file.path)
               }).code)))
               .pipe(gulp.dest('.'));
};

regenerate.description = 'Invokes babel on the files in config, transpiling them into their project root versions';

// * EJECT

const eject = () => term.prompt([
    {
        type: 'input',
        name: 'package.name',
        message: '[package.json] Specify name for this project (must be valid as a directory name)'
    },
    {
        type: 'input',
        name: 'package.desc',
        message: '[package.json] Very briefly describe this project',
    },
    {
        type: 'input',
        name: 'package.repo.url',
        message: '[package.json] Specify a git repository URL'
    },
    {
        type: 'input',
        name: 'debug.address',
        message: '[launch.json] Specify your dev/remote/server ip address (the one running node)',
        default: '192.168.115.5'
    },
    {
        type: 'input',
        name: 'debug.url',
        message: '[launch.json] Specify the URL entry point for your application',
        default: 'http://dev.local:80'
    },
    {
        type: 'input',
        name: 'debug.remoteRoot',
        message: "[launch.json] Specify an *absolute* path to this project's root on remote/server"
    },
    {
        type: 'confirm',
        name: 'installTypes',
        message: 'Do you want to install Flow types for all local packages?',
        default: true
    },
    {
        type: 'confirm',
        name: 'confirm',
        message: 'Does everything look good?',
        default: false
    }
]).then(async answers => {
    if(!answers.confirm)
        return log.error('Task aborted!');

    try {
        log.info(`Moving ${paths.envDist} -> ${paths.env}`);
        sh.mv(paths.envDist, paths.env);

        log.info(`Moving ${paths.launchJsonDist} -> ${paths.launchJson}`);
        sh.mv(paths.launchJsonDist, paths.launchJson);

        log.info(`Mutating ${paths.packageJson}`);
        const delta1 = await replaceInFile({
            files: paths.packageJson,
            from: [/("name": ?)".*?"/g, /("description": ?)".*?"/g, /("url": ?)".*?"/g],
            to: [`$1"${answers.package.name}"`, `$1"${answers.package.desc}"`, `$1"${answers.package.repo.url}"`],
        });

        log.info(`Mutating ${paths.launchJson}`);
        const delta2 = await replaceInFile({
            files: paths.launchJson,
            from: [/("address": ?)".*?"/g, /("remoteRoot": ?)".*?"/g, /("url": ?)".*?"/g],
            to: [`$1"${answers.debug.address}"`, `$1"${answers.debug.remoteRoot}"`, `$1"${answers.debug.url}"`],
        });

        log.info(`Mutating ${paths.gitIgnore}`);
        const delta3 = await replaceInFile({
            files: paths.gitIgnore,
            from: 'package-lock.json',
            to: '',
        });

        if(!delta1.length)
            throw new Error(`There was an error attempting to access "${paths.packageJson}"`);

        if(!delta2.length)
            throw new Error(`There was an error attempting to access "${paths.launchJson}"`);

        if(!delta3.length)
            throw new Error(`There was an error attempting to access "${paths.gitignore}"`);

        if(answers.installTypes)
        {
            log.info(`Installing flow types (please be patient)`);
            sh.exec('npm run install-types');
        }

        log.info(`Removing ${paths.packageLockJson}`);
        sh.rm('-f', paths.packageLockJson);

        log.info('Removing boilerplate git repository');
        sh.rm('-rf', '.git');

        log.info('Initializing new git repository');
        sh.exec('git init');

        log.info(`Renaming project dir to ${answers.package.name}`);
        sh.exec(`cd .. && mv '${parsePath(__dirname).name}' '${answers.package.name}'`);

        log.info(chalk.green('Boilerplate ejection completed successfully!'));
        log(`Next steps:
\t- If you're going to host this project on Github/Gitlab, begin that process now
\t- Check over ${paths.packageJson} for accuracy; remove any unnecessary dependencies/devDependencies and run scripts
\t- Check over ${paths.launchJson} if you plan on using launch configurations
\t- Look over ${paths.env} and configure it to your liking
\t- Consider removing ${paths.env} from ${paths.gitIgnore} if there're no secret values being passed
\t- Your Gulp file is at ./${paths.configs}/gulpfile.js ${chalk.bold('and not the project root')}. Feel free to customize it!\n`);
    }

    catch(err) {
        log.error(chalk.red(`ERROR: ${err.toString()}`));
    }
});

eject.description = 'Assists in configuring the boilerplate to be something useful';

export { eject, regenerate, cleanTypes };
