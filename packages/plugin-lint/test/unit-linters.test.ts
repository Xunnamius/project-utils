/* eslint-disable jest/no-conditional-expect */
import fs from 'fs/promises';
import { readFileSync } from 'fs';
import * as Linters from '../src/linters';
import * as Constants from '../src/constants';
import * as Utils from '../src/utils';
import * as UtilsMdast from '../src/utils/mdast';
import { glob, sync as globSync } from 'glob';
import { promisify } from 'util';
import { Fixtures, patchReadPackageJsonData } from 'testverse/fixtures';
import { toss } from 'toss-expression';
import { ErrorMessage } from '../src/errors';
import { clearPackageJsonCache } from 'pkgverse/core/src/project-utils';
import { asMockedFunction } from '@xunnamius/jest-types';
import { run, RunReturnType } from 'multiverse/run';
import { TrialError } from 'named-app-errors';
import { basename } from 'path';
import escapeRegexp from 'escape-string-regexp';
// ? Secretly an ES module, but mocked as a CJS module
import { fromMarkdown } from 'mdast-util-from-markdown';

import type { PathLike } from 'fs';

jest.mock('multiverse/run');

jest.mock('mdast-util-from-markdown', () => {
  return {
    fromMarkdown: jest.fn(),
    __esModule: true
  };
});

const globAsync = promisify(glob);

/**
 * Check if a string contains a particular error or warning message generated by
 * a specific file.
 */
const stringContainingErrorMessage = (
  type: Utils.ReportType,
  currentFile: string,
  errorMessage: string
) => {
  return expect.stringMatching(
    RegExp(
      `^.*${escapeRegexp(currentFile)}(?!/).*(?:\n  .*?)*(?:\n  .*?${
        type == 'warn' ? 'warn' : 'ERR!'
      }.*?) ${escapeRegexp(errorMessage)}$`,
      'm'
    )
  );
};

/**
 * Returns a function used to mock calls to `git commit`
 */
const makeMockGitCommit =
  (commits: string[]): typeof run =>
  (_, args) => {
    if (args?.includes('A...B')) {
      commits.push(Math.random().toString(16).slice(2, 8));
      commits.push(Math.random().toString(16).slice(2, 8));
      return {
        stdout: `${commits.at(-2)} X Y Z\n${commits.at(-1)} A B C`
      } as unknown as ReturnType<typeof run>;
    } else {
      return {
        stdout: '## A...B\none two-three\nfour five-six'
      } as unknown as ReturnType<typeof run>;
    }
  };

/**
 * Disabled links from `getBadMarkdown`.
 */
const getBadLines = () =>
  [
    'Test link badness: \\[bad link]\\[bad-link] and \\[another bad link]\\[bad-link-2].',
    'JavaScript/TypeScript build output, and \\[Remark]\\[3] and [mdast][17] for'
  ] as const;

/**
 * Sample Markdown paragraph containing disabled links.
 */
const getBadMarkdown = () =>
  Promise.resolve(
    `
# @projector-js/plugin-lint

> See the [usage section][4] for more information.

Test link badness: \\[bad link]\\[bad-link] and \\[another bad link]\\[bad-link-2].

This opinionated CLI tool checks a Node.js project for correctness. It should be
run [after the project has been built][18]. TypeScript ([tsc][1]) is used for
type checking, [ESLint][2] and [Babel][16] for static analysis of
JavaScript/TypeScript build output, and \\[Remark]\\[3] and [mdast][17] for
analysis of Markdown source. Further checks are performed to ensure the project
is optimally structured and conforms to best practices, including detecting when
running in a monorepo root vs a polyrepo root vs a sub-root.` as const
  );

const actualRun = jest.requireActual('multiverse/run').run;
const mockedRun = asMockedFunction(run);
const mockedFromMarkdown = asMockedFunction(fromMarkdown);

const mockMdastReadmeMonorepo = require('testverse/fixtures/mdast.readme-monorepo');
const mockMdastReadmeMonorepoOOOrder = require('testverse/fixtures/mdast.readme-monorepo-ooo');
const mockMdastSecurity = require('testverse/fixtures/mdast.security');
const mockMdastContributing = require('testverse/fixtures/mdast.contributing');
const mockMdastSupport = require('testverse/fixtures/mdast.support');

const blueprints: Record<string, string> = {};

beforeAll(() => {
  globSync(`${__dirname}/../src/blueprints/*`, { absolute: true }).forEach(
    (blueprintPath) => {
      const blueprintName = basename(blueprintPath).split('.')[0];

      if (blueprints[blueprintName]) {
        throw new TrialError(`blueprint name collision: ${blueprintName}`);
      }

      blueprints[blueprintName] = readFileSync(blueprintPath, { encoding: 'utf-8' });
    }
  );
});

beforeEach(() => {
  mockedRun.mockImplementation(() =>
    Promise.resolve({ stdout: '' } as unknown as RunReturnType)
  );
  mockedFromMarkdown.mockImplementation(() => ({ type: 'root', children: [] }));
  clearPackageJsonCache();
});

test('certain markdown blueprints end with a colon and not a new line', async () => {
  expect.assertions(3);

  await globAsync(
    `${__dirname}/../src/blueprints/{contributing,security,support}.md.txt`,
    { absolute: true }
  ).then((files) => {
    return Promise.all(
      files.map((file) => {
        return fs
          .readFile(file, {
            encoding: 'utf-8'
          })
          .then((blueprint) => expect(blueprint).toEndWith(':'));
      })
    );
  });
});

describe('::runProjectLinter', () => {
  it('errors when the project is not a git repository', async () => {
    expect.hasAssertions();

    await expect(
      Linters.runProjectLinter({
        rootDir: Fixtures.repoThatDoesNotExist.root,
        linkProtectionMarkdownPaths: []
      })
    ).resolves.toStrictEqual({
      success: false,
      summary: expect.stringContaining('1 error, 0 warnings'),
      output: stringContainingErrorMessage(
        'error',
        Fixtures.repoThatDoesNotExist.root,
        ErrorMessage.NotAGitRepository()
      )
    });
  });

  it('errors when package.json file is missing', async () => {
    expect.hasAssertions();

    await expect(
      Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoNonPackageDir.root,
        linkProtectionMarkdownPaths: []
      })
    ).resolves.toStrictEqual({
      success: false,
      summary: expect.stringContaining('1 error, 0 warnings'),
      output: stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepoNonPackageDir.root}/package.json`,
        ErrorMessage.FatalMissingFile()
      )
    });
  });

  it('errors when package.json file is unparsable', async () => {
    expect.hasAssertions();

    jest.spyOn(JSON, 'parse').mockImplementation(() => toss(new Error('badness')));

    await expect(
      Linters.runProjectLinter({
        rootDir: Fixtures.goodMonorepo.root,
        linkProtectionMarkdownPaths: []
      })
    ).resolves.toStrictEqual({
      success: false,
      summary: expect.stringContaining('1 error, 0 warnings'),
      output: stringContainingErrorMessage(
        'error',
        `${Fixtures.goodMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonUnparsable()
      )
    });
  });

  it('reports errors from sub-roots when explicitly linting a monorepo root', async () => {
    expect.hasAssertions();

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    // ? Also lints sub-roots when linting a monorepo root
    Constants.globalPkgJsonRequiredFields.forEach((field) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });
  });

  it('does not report errors from other sub-roots when explicitly linting one sub-root', async () => {
    expect.hasAssertions();

    const monorepoOtherSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[1][1].root,
      linkProtectionMarkdownPaths: []
    });

    // ? Linting one sub-root should not report errors from a different sub-root
    Constants.globalPkgJsonRequiredFields.forEach((field) => {
      expect(monorepoOtherSubRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });
  });

  it('errors when the dist directory or its subdirectories contain .tsbuildinfo files', async () => {
    expect.hasAssertions();

    const monorepo = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepo = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepoTsbuildinfo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepo.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[1][1].root}/dist/tsconfig.fake.tsbuildinfo`,
        ErrorMessage.IllegalItemInDirectory(
          `${Fixtures.badMonorepo.unnamedPkgMapData[1][1].root}/dist`
        )
      )
    );

    expect(monorepo.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[1][1].root}/dist/sub-dir/tsconfig.fake2.tsbuildinfo`,
        ErrorMessage.IllegalItemInDirectory(
          `${Fixtures.badMonorepo.unnamedPkgMapData[1][1].root}/dist`
        )
      )
    );

    expect(polyrepo.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepoTsbuildinfo.root}/dist/tsconfig.fake.tsbuildinfo`,
        ErrorMessage.IllegalItemInDirectory(
          `${Fixtures.badPolyrepoTsbuildinfo.root}/dist`
        )
      )
    );
  });

  it('errors when package.json does not contain necessary fields', async () => {
    expect.hasAssertions();

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.globalPkgJsonRequiredFields.forEach((field) => {
      // ? Works when linting a monorepo root
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );

      // ? Works when linting a sub-root explicitly
      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );

      // ? Works when linting a polyrepo root
      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });
  });

  it('errors when package.json does not contain certain fields except when in a monorepo root', async () => {
    expect.hasAssertions();

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.nonMonoRootPkgJsonRequiredFields.forEach((field) => {
      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });

    Constants.nonMonoRootPkgJsonRequiredFields.forEach((field) => {
      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });

    Constants.nonMonoRootPkgJsonRequiredFields.forEach((field) => {
      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });
  });

  it('errors when package.json does not contain certain fields except when in a monorepo root or if the "private" field is set to "true"', async () => {
    expect.hasAssertions();

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    patchReadPackageJsonData({
      [Fixtures.badMonorepo.unnamedPkgMapData[0][1].root]: {
        private: true
      }
    });

    const monorepoPrivateSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    patchReadPackageJsonData({
      [Fixtures.badPolyrepo.root]: {
        private: true
      }
    });

    const polyrepoPrivateRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.publicPkgJsonRequiredFields.forEach((field) => {
      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });

    Constants.publicPkgJsonRequiredFields.forEach((field) => {
      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });

    Constants.publicPkgJsonRequiredFields.forEach((field) => {
      expect(monorepoPrivateSubRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[2][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });

    Constants.publicPkgJsonRequiredFields.forEach((field) => {
      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });

    Constants.publicPkgJsonRequiredFields.forEach((field) => {
      expect(polyrepoPrivateRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(field)
        )
      );
    });
  });

  it('errors when the same dependency appears under both "dependencies" and "devDependencies" fields in package.json', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        dependencies: {
          async: '^3.2.3',
          chalk: '4.0.0-pinned',
          jest: 'next'
        },
        devDependencies: {
          async: '^3.2.4',
          chalk: '3.0.0-pinned',
          jest: 'next'
        }
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonDuplicateDependency('async')
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonDuplicateDependency('async')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonDuplicateDependency('async')
      )
    );
  });

  it('errors when package.json contains the "files" field but its array is missing necessary values', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        files: []
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.pkgJsonRequiredFiles.forEach((field) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingValue('files', field)
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingValue('files', field)
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingValue('files', field)
        )
      );
    });
  });

  it('errors when package.json "exports" field is missing self-referencing entry points', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        exports: null
      }
    });

    const monorepoSubRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    patchReadPackageJsonData({
      ['*']: {
        exports: './dist/nope.js',
        typesVersions: {
          '*': {
            '*': ['./dist/types/src/*']
          }
        }
      }
    });

    const monorepoSubRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoSubRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package')
      )
    );

    expect(monorepoSubRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package.json')
      )
    );

    expect(monorepoSubRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package')
      )
    );

    expect(monorepoSubRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package.json')
      )
    );

    expect(polyrepoRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package')
      )
    );

    expect(polyrepoRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package.json')
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package')
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingEntryPoint('./package.json')
      )
    );
  });

  it('errors when missing required files', async () => {
    expect.hasAssertions();

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.requiredFiles.forEach((file) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.root}/${file}`,
          ErrorMessage.MissingFile()
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/${file}`,
          ErrorMessage.MissingFile()
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepo.root}/${file}`,
          ErrorMessage.MissingFile()
        )
      );
    });
  });

  it('errors when unpublished git commits have certain keywords in their subject', async () => {
    expect.hasAssertions();
    const commits: string[] = [];

    mockedRun.mockImplementation(makeMockGitCommit(commits));

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    commits.forEach((commit) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `git commit ${commit}`,
          ErrorMessage.CommitNeedsFixup()
        )
      );
    });

    commits.splice(0, commits.length);

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    commits.forEach((commit) => {
      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `git commit ${commit}`,
          ErrorMessage.CommitNeedsFixup()
        )
      );
    });
  });

  it('errors when any "exports" or "typesVersions" entry points in package.json point to files that do not exist', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        exports: './dist/nope.js',
        typesVersions: {
          '*': {
            '*': ['./dist/types/src/*']
          }
        }
      }
    });

    const monorepoSubRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    patchReadPackageJsonData({
      ['*']: {
        exports: {
          '.': {
            require: ['./dist/nope.cjs', './dist/index.js'],
            node: {
              custom: './dist/nope.js',
              default: './dist/index.js'
            },
            default: './dist/nope.js'
          },
          './package': './package-x.json',
          './package.json': './package.json'
        },
        typesVersions: {
          '*': {
            'special.d.ts': ['./does-not-exist'],
            '*': ['./does-not-exist', './dist/types/src/*']
          }
        }
      }
    });

    const monorepoSubRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoSubRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonBadTypesEntryPoint(['*', '*'])
      )
    );

    expect(monorepoSubRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonBadTypesEntryPoint(['*', 'special.d.ts'])
      )
    );

    expect(monorepoSubRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonBadEntryPoint(['.', 'default'])
      )
    );

    expect(monorepoSubRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonBadEntryPoint(['.', 'node', 'custom'])
      )
    );

    expect(monorepoSubRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonBadEntryPoint(['./package'])
      )
    );

    expect(polyrepoRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonBadTypesEntryPoint(['*', '*'])
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonBadTypesEntryPoint(['*', 'special.d.ts'])
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonBadEntryPoint(['.', 'default'])
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonBadEntryPoint(['.', 'node', 'custom'])
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonBadEntryPoint(['./package'])
      )
    );
  });

  it('warns when missing certain tsconfig files in a polyrepo or monorepo root', async () => {
    expect.hasAssertions();

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.monorepoRootTsconfigFiles.forEach((file) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/${file}`,
          ErrorMessage.MissingFile()
        )
      );
    });

    Constants.polyrepoTsconfigFiles.forEach((file) => {
      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/${file}`,
          ErrorMessage.MissingFile()
        )
      );
    });
  });

  it('warns when missing certain other tsconfig files in a monorepo sub-root', async () => {
    expect.hasAssertions();

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    Constants.subRootTsconfigFiles.forEach((file) => {
      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/${file}`,
          ErrorMessage.MissingFile()
        )
      );
    });
  });

  it('warns when package.json "license" field is not "MIT"', async () => {
    expect.hasAssertions();

    const monorepoRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    patchReadPackageJsonData({
      ['*']: {
        license: 'ISC'
      }
    });

    const monorepoRoot3 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot4 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingValue('license', Constants.pkgJsonLicense)
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingValue('license', Constants.pkgJsonLicense)
      )
    );

    expect(monorepoRoot3.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingValue('license', Constants.pkgJsonLicense)
      )
    );

    expect(polyrepoRoot4.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingValue('license', Constants.pkgJsonLicense)
      )
    );
  });

  it('warns when package.json version field is experimental', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        version: '0.0.0-develop'
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    patchReadPackageJsonData({
      ['*']: {
        version: '0.0.1'
      }
    });

    const monorepoSubRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    patchReadPackageJsonData({});

    const goodMonorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.goodMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonIllegalKey('version')
      )
    );

    expect(monorepoSubRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonExperimentalVersion()
      )
    );

    expect(monorepoSubRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonExperimentalVersion()
      )
    );

    expect(polyrepoRoot1.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonExperimentalVersion()
      )
    );

    expect(polyrepoRoot2.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonExperimentalVersion()
      )
    );

    expect(goodMonorepoRoot.output).not.toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.goodMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonIllegalKey('version')
      )
    );

    expect(goodMonorepoRoot.output).not.toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.goodMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonExperimentalVersion()
      )
    );
  });

  it('warns when package.json contains outdated entry point fields', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        main: './dist/index.js',
        module: './dist/index.js',
        types: './dist/types/index.d.ts',
        typesVersions: { '*': { '*': ['./dist/types/index.d.ts'] } }
      }
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.pkgJsonObsoleteEntryKeys.forEach((key) => {
      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonObsoleteKey(key)
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonObsoleteKey(key)
        )
      );
    });
  });

  it('warns when package.json contains outdated script field names', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        scripts: {
          'test-integration-webpack': 'true',
          'test-integration-webpack-deep': 'true',
          'test-integration-browser': 'true',
          'test-integration-browser-deep': 'true',
          prepublishOnly: 'true',
          postpublish: 'true',
          repl: 'true',
          preinstall: 'true',
          postinstall: 'true',
          fixup: 'true',
          'check-types': 'true',
          publishGuard: 'true'
        }
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.pkgJsonObsoleteScripts.forEach((key) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonObsoleteScript(key)
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonObsoleteScript(key)
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonObsoleteScript(key)
        )
      );
    });
  });

  it('warns when package.json missing expected "scripts" field keys', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        scripts: {}
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    const nextMonorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepoNextjsProject.root,
      linkProtectionMarkdownPaths: []
    });

    const nextPolyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepoNextjsProject.root,
      linkProtectionMarkdownPaths: []
    });

    Constants.monorepoRootScripts.forEach((key) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(`scripts['${key}']`)
        )
      );
    });

    Constants.subRootScripts.forEach((key) => {
      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(`scripts['${key}']`)
        )
      );
    });

    Constants.polyrepoScripts.forEach((key) => {
      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(`scripts['${key}']`)
        )
      );
    });

    Constants.monorepoRootScripts.forEach((key) => {
      expect(nextMonorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoNextjsProject.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(`scripts['${key}']`)
        )
      );
    });

    Constants.nextjsProjectRootAdditionalScripts.forEach((key) => {
      expect(nextMonorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoNextjsProject.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(`scripts['${key}']`)
        )
      );
    });

    Constants.polyrepoScripts.forEach((key) => {
      expect(nextPolyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoNextjsProject.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(`scripts['${key}']`)
        )
      );
    });

    Constants.nextjsProjectRootAdditionalScripts.forEach((key) => {
      expect(nextPolyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoNextjsProject.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey(`scripts['${key}']`)
        )
      );
    });
  });

  it('warns when package.json missing "engines.node" field', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        engines: {}
      }
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingKey('engines.node')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingKey('engines.node')
      )
    );
  });

  it('warns when package.json "engines.node" field is not expected semver', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        engines: {
          node: '>1.2.3'
        }
      }
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    const engines = Utils.getExpectedPkgNodeEngines();

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonBadEngine(engines)
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonBadEngine(engines)
      )
    );
  });

  it('warns when package.json contains a pinned dependency/devDependency', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        dependencies: {
          chalk: '4.0.0-pinned',
          npm: '^1.2.3',
          rest: '^1.2.3-prerelease'
        },
        devDependencies: {
          async: '3.2.3',
          npm: '^1.2.3',
          rest: '^1.2.3-prerelease'
        }
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonPinnedDependency('chalk')
      )
    );

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonPinnedDependency('async')
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonPinnedDependency('chalk')
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonPinnedDependency('async')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonPinnedDependency('chalk')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonPinnedDependency('async')
      )
    );

    ['npm', 'rest'].forEach((dep) => {
      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonNonSemverDependency(dep)
        )
      );

      expect(monorepoSubRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonNonSemverDependency(dep)
        )
      );

      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonNonSemverDependency(dep)
        )
      );
    });
  });

  it('warns when package.json contains a dist-tag dependency/devDependency', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        dependencies: {
          jest: 'next',
          fest: '1.2.3',
          npm: '^1.2.3',
          rest: '^1.2.3-prerelease'
        },
        devDependencies: {
          async: 'latest',
          fest: '1.2.3',
          npm: '^1.2.3',
          rest: '^1.2.3-prerelease'
        }
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonNonSemverDependency('jest')
      )
    );

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonNonSemverDependency('async')
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonNonSemverDependency('jest')
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonNonSemverDependency('async')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonNonSemverDependency('jest')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonNonSemverDependency('async')
      )
    );

    ['fest', 'npm', 'rest'].forEach((dep) => {
      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonNonSemverDependency(dep)
        )
      );

      expect(monorepoSubRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonNonSemverDependency(dep)
        )
      );

      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonNonSemverDependency(dep)
        )
      );
    });
  });

  it('errors when package.json contains a non-pinned pre-release dependency/devDependency', async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        dependencies: {
          jest: '^28.0.0-alpha.7',
          rest: '28.0.0-alpha.7'
        },
        devDependencies: {
          async: '^28.0.0-beta'
        }
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('jest')
      )
    );

    expect(monorepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('async')
      )
    );

    expect(monorepoRoot.output).not.toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('rest')
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('jest')
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('async')
      )
    );

    expect(monorepoSubRoot.output).not.toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('rest')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('jest')
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('async')
      )
    );

    expect(polyrepoRoot.output).not.toStrictEqual(
      stringContainingErrorMessage(
        'error',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonNonPinnedPreReleaseDependency('rest')
      )
    );
  });

  it(`warns when package.json "config['plugin-build']".docs.entry is missing`, async () => {
    expect.hasAssertions();

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot.output).not.toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingKey("config['plugin-build'].docs.entry")
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonMissingKey("config['plugin-build'].docs.entry")
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonMissingKey("config['plugin-build'].docs.entry")
      )
    );
  });

  it(`warns when package.json "config['plugin-build'].docs.entry" points to a non-existent path`, async () => {
    expect.hasAssertions();

    patchReadPackageJsonData({
      ['*']: {
        config: {
          'plugin-build': {
            docs: {
              entry: './does/not/exist.js'
            }
          }
        }
      }
    });

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.root,
      linkProtectionMarkdownPaths: []
    });

    const monorepoSubRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: []
    });

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepo.root,
      linkProtectionMarkdownPaths: []
    });

    expect(monorepoRoot.output).not.toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.root}/package.json`,
        ErrorMessage.PackageJsonBadConfigDocsEntry()
      )
    );

    expect(monorepoSubRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
        ErrorMessage.PackageJsonBadConfigDocsEntry()
      )
    );

    expect(polyrepoRoot.output).toStrictEqual(
      stringContainingErrorMessage(
        'warn',
        `${Fixtures.badPolyrepo.root}/package.json`,
        ErrorMessage.PackageJsonBadConfigDocsEntry()
      )
    );
  });

  it('errors when any Markdown files contain disabled links unless ignored via config', async () => {
    expect.hasAssertions();

    jest.spyOn(fs, 'readFile').mockImplementation(() => getBadMarkdown());

    const monorepoRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob]
    });

    const monorepoSubRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob]
    });

    const polyrepoRoot1 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob]
    });

    patchReadPackageJsonData({
      [Fixtures.badMonorepoEmptyMdFiles.root]: {
        config: {
          'plugin-lint': {
            'link-protection': {
              ignore: ['CONTRIBUTING.md']
            }
          }
        }
      },
      ['*']: {
        config: {
          'plugin-lint': {
            'link-protection': {
              ignore: ['README.md']
            }
          }
        }
      }
    });

    const monorepoRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob]
    });

    const monorepoSubRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob]
    });

    const polyrepoRoot2 = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob]
    });

    getBadLines().forEach((badLine) => {
      expect(monorepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/CONTRIBUTING.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/RANDOM.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoSubRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoSubRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/RANDOM.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(polyrepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/CONTRIBUTING.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      // ? Glob "ignore" configs (with relative paths) that are in sub-roots
      // ? should be respected even when plugin-lint is run from the repo root
      expect(monorepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot2.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/RANDOM.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoSubRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoSubRoot2.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/RANDOM.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(polyrepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );
    });
  });

  describe('(topmatter/link README.md tests)', () => {
    beforeEach(() => {
      const readFileSpy = jest.spyOn(fs, 'readFile');
      const _access = fs.access;
      const accessSpy = jest.spyOn(fs, 'access');

      readFileSpy.mockImplementation(() => Promise.resolve(''));
      accessSpy.mockImplementation((path: PathLike, mode?: number) =>
        path.toString().endsWith('/README.md') ? Promise.resolve() : _access(path, mode)
      );
    });

    it('warns when README.md is missing topmatter opening comment', async () => {
      expect.hasAssertions();

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxOpeningComment()
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxOpeningComment()
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxOpeningComment()
        )
      );
    });

    it('warns when README.md is missing topmatter closing comment', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxClosingComment()
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxClosingComment()
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxClosingComment()
        )
      );
    });

    it('warns when README.md has invalid badge syntax', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: [
              {
                type: 'linkReference',
                children: [],
                position: {
                  start: { line: 5, column: 1, offset: 55 },
                  end: { line: 5, column: 46, offset: 100 }
                },
                label: 'link-blm',
                identifier: 'link-blm',
                referenceType: 'full'
              }
            ]
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: [
              {
                type: 'linkReference',
                children: [],
                position: {
                  start: { line: 5, column: 1, offset: 55 },
                  end: { line: 5, column: 46, offset: 100 }
                },
                label: '',
                identifier: '',
                referenceType: 'full'
              }
            ]
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          }
        ]
      }));

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxLinkRef('link-blm')
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxLinkRef('link-blm')
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownInvalidSyntaxLinkRef('(unlabeled)')
        )
      );
    });

    it('warns when README.md has unknown topmatter', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => mockMdastReadmeMonorepo);

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownUnknownTopmatterItem('badge-projector')
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownUnknownTopmatterItem('badge-projector')
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownUnknownTopmatterItem('badge-projector')
        )
      );
    });

    it('warns when README.md has a bad badge', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: [
              {
                type: 'linkReference',
                children: [
                  {
                    type: 'imageReference',
                    alt: 'BLM!',
                    position: {
                      start: { line: 5, column: 2, offset: 56 },
                      end: { line: 5, column: 35, offset: 89 }
                    },
                    label: 'badge-blm',
                    identifier: 'badge-blm',
                    referenceType: 'full'
                  }
                ],
                position: {
                  start: { line: 5, column: 1, offset: 55 },
                  end: { line: 5, column: 46, offset: 100 }
                },
                label: 'blm-link',
                identifier: 'blm-link',
                referenceType: 'full'
              }
            ]
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterLinkRefLabel(
            'blm-link',
            Constants.markdownReadmeStandardTopmatter.badge.blm.link.label
          )
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterLinkRefLabel(
            'blm-link',
            Constants.markdownReadmeStandardTopmatter.badge.blm.link.label
          )
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterLinkRefLabel(
            'blm-link',
            Constants.markdownReadmeStandardTopmatter.badge.blm.link.label
          )
        )
      );

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefAlt(
            'badge-blm',
            Constants.markdownReadmeStandardTopmatter.badge.blm.alt
          )
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefAlt(
            'badge-blm',
            Constants.markdownReadmeStandardTopmatter.badge.blm.alt
          )
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefAlt(
            'badge-blm',
            Constants.markdownReadmeStandardTopmatter.badge.blm.alt
          )
        )
      );

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterMissingLinkRefDef('blm-link')
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterMissingLinkRefDef('blm-link')
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterMissingLinkRefDef('blm-link')
        )
      );
    });

    it('warns when README.md has a bad image reference', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: [
              {
                type: 'linkReference',
                children: [
                  {
                    type: 'imageReference',
                    alt: 'BLM!',
                    position: {
                      start: { line: 5, column: 2, offset: 56 },
                      end: { line: 5, column: 35, offset: 89 }
                    },
                    label: 'badge-blm',
                    identifier: 'badge-blm',
                    referenceType: 'full'
                  }
                ],
                position: {
                  start: { line: 5, column: 1, offset: 55 },
                  end: { line: 5, column: 46, offset: 100 }
                },
                label: 'link-blm',
                identifier: 'link-blm',
                referenceType: 'full'
              }
            ]
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'definition',
            identifier: 'link-blm',
            label: 'link-blm',
            title: null,
            url: 'https://xunn.at/donate-blm',
            position: {
              start: { line: 967, column: 1, offset: 32180 },
              end: { line: 967, column: 39, offset: 32218 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterMissingImageRefDef(
            Constants.markdownReadmeStandardTopmatter.badge.blm.label
          )
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterMissingImageRefDef(
            Constants.markdownReadmeStandardTopmatter.badge.blm.label
          )
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterMissingImageRefDef(
            Constants.markdownReadmeStandardTopmatter.badge.blm.label
          )
        )
      );
    });

    it('warns when missing repository url and/or name while checking README.md', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: [
              {
                type: 'linkReference',
                children: [
                  {
                    type: 'imageReference',
                    alt: 'BLM!',
                    position: {
                      start: { line: 5, column: 2, offset: 56 },
                      end: { line: 5, column: 35, offset: 89 }
                    },
                    label: 'badge-blm',
                    identifier: 'badge-blm',
                    referenceType: 'full'
                  }
                ],
                position: {
                  start: { line: 5, column: 1, offset: 55 },
                  end: { line: 5, column: 46, offset: 100 }
                },
                label: 'link-blm',
                identifier: 'link-blm',
                referenceType: 'full'
              }
            ]
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'definition',
            identifier: 'link-blm',
            label: 'link-blm',
            title: null,
            url: 'https://xunn.at/donate-blm',
            position: {
              start: { line: 967, column: 1, offset: 32180 },
              end: { line: 967, column: 39, offset: 32218 }
            }
          },
          {
            type: 'definition',
            identifier: 'badge-blm',
            label: 'badge-blm',
            title: null,
            url: 'https://xunn.at/donate-blm',
            position: {
              start: { line: 967, column: 1, offset: 32180 },
              end: { line: 967, column: 39, offset: 32218 }
            }
          }
        ]
      }));

      patchReadPackageJsonData({
        [Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root]: {
          repository: 'https://github.com/user/repo'
        },
        [Fixtures.badPolyrepoEmptyMdFiles.root]: {
          repository: { type: 'git', url: 'https://github.com/user/repo' }
        }
      });

      const monorepoRoot1 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot1 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot1 = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      patchReadPackageJsonData({
        ['*']: {
          name: Math.random().toString(16).slice(2),
          repository: 'https://github.com/user/repo'
        },
        [Fixtures.badPolyrepoEmptyMdFiles.root]: {
          repository: { type: 'git', url: 'https://github.com/user/repo' }
        }
      });

      const monorepoRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.PackageJsonMissingKeysCheckSkipped()
        )
      );

      expect(monorepoSubRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.PackageJsonMissingKeysCheckSkipped()
        )
      );

      expect(polyrepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.PackageJsonMissingKeysCheckSkipped()
        )
      );

      expect(monorepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.PackageJsonMissingKeysCheckSkipped()
        )
      );

      expect(monorepoSubRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.PackageJsonMissingKeysCheckSkipped()
        )
      );

      expect(polyrepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.PackageJsonMissingKeysCheckSkipped()
        )
      );
    });

    it('warns when README.md has a bad definition', async () => {
      expect.hasAssertions();

      patchReadPackageJsonData(
        {
          ['*']: {
            repository: { type: 'git', url: 'https://github.com/user/repo' },
            name: `pkg-${Math.random().toString(16).slice(10)}`
          }
        },
        { replace: false }
      );

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: [
              {
                type: 'linkReference',
                children: [
                  {
                    type: 'imageReference',
                    alt: 'LCT',
                    position: {
                      start: { line: 6, column: 2, offset: 102 },
                      end: { line: 6, column: 45, offset: 145 }
                    },
                    label: 'badge-last-commit',
                    identifier: 'badge-last-commit',
                    referenceType: 'full'
                  }
                ],
                position: {
                  start: { line: 6, column: 1, offset: 101 },
                  end: { line: 6, column: 57, offset: 157 }
                },
                label: 'link-last-commit',
                identifier: 'link-last-commit',
                referenceType: 'full'
              }
            ]
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'definition',
            identifier: 'link-last-commit',
            label: 'link-last-commit',
            title: null,
            url: 'https://github.com/x/y',
            position: {
              start: { line: 968, column: 1, offset: 32219 },
              end: { line: 968, column: 52, offset: 32270 }
            }
          },
          {
            type: 'definition',
            identifier: 'badge-last-commit',
            label: 'badge-last-commit',
            title: 'LCT',
            url: 'https://img.shields.io/github/last-commit/x/y',
            position: {
              start: { line: 969, column: 1, offset: 32271 },
              end: { line: 971, column: 28, offset: 32383 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefDefTitle(
            'badge-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.title
          )
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefDefTitle(
            'badge-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.title
          )
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefDefTitle(
            'badge-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.title
          )
        )
      );

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefDefUrl(
            'badge-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefDefUrl(
            'badge-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterImageRefDefUrl(
            'badge-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterLinkRefDefUrl(
            'link-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.link.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterLinkRefDefUrl(
            'link-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.link.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadTopmatterLinkRefDefUrl(
            'link-last-commit',
            Constants.markdownReadmeStandardTopmatter.badge.lastCommit.link.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );
    });

    it('warns when README.md is missing topmatter', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: []
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownMissingTopmatter()
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownMissingTopmatter()
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownMissingTopmatter()
        )
      );
    });

    it('warns when README.md topmatter is out of order', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => mockMdastReadmeMonorepoOOOrder);

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownTopmatterOutOfOrder()
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownTopmatterOutOfOrder()
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownTopmatterOutOfOrder()
        )
      );
    });

    it('warns when README.md is missing specific topmatter items', async () => {
      expect.hasAssertions();

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'html',
            value: '<!-- badges-start -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          },
          {
            type: 'paragraph',
            children: [
              {
                type: 'linkReference',
                children: [
                  {
                    type: 'imageReference',
                    alt: 'LCT',
                    position: {
                      start: { line: 6, column: 2, offset: 102 },
                      end: { line: 6, column: 45, offset: 145 }
                    },
                    label: 'badge-last-commit',
                    identifier: 'badge-last-commit',
                    referenceType: 'full'
                  }
                ],
                position: {
                  start: { line: 6, column: 1, offset: 101 },
                  end: { line: 6, column: 57, offset: 157 }
                },
                label: 'link-last-commit',
                identifier: 'link-last-commit',
                referenceType: 'full'
              }
            ]
          },
          {
            type: 'html',
            value: '<!-- badges-end -->',
            position: {
              start: { line: 3, column: 1, offset: 32 },
              end: { line: 3, column: 22, offset: 53 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      Object.values(Constants.markdownReadmeStandardTopmatter.badge)
        .filter(({ label }) => label != 'badge-last-commit')
        .forEach(({ label, conditions }) => {
          if (conditions.includes('monorepo')) {
            expect(monorepoRoot.output).toStrictEqual(
              stringContainingErrorMessage(
                'warn',
                `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
                ErrorMessage.MarkdownMissingTopmatterItem(label)
              )
            );
          }

          if (conditions.includes('subroot')) {
            expect(monorepoSubRoot.output).toStrictEqual(
              stringContainingErrorMessage(
                'warn',
                `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
                ErrorMessage.MarkdownMissingTopmatterItem(label)
              )
            );
          }

          if (conditions.includes('polyrepo')) {
            expect(polyrepoRoot.output).toStrictEqual(
              stringContainingErrorMessage(
                'warn',
                `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
                ErrorMessage.MarkdownMissingTopmatterItem(label)
              )
            );
          }
        });
    });

    it('warns when README.md is missing specific standard link references', async () => {
      expect.hasAssertions();

      patchReadPackageJsonData(
        {
          ['*']: {
            repository: { type: 'git', url: 'https://github.com/user/repo' },
            name: `pkg-${Math.random().toString(16).slice(10)}`
          }
        },
        { replace: false }
      );

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: []
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      Object.values(Constants.markdownReadmeStandardLinks).forEach(({ label }) => {
        expect(monorepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
            ErrorMessage.MarkdownMissingLink(label)
          )
        );

        expect(monorepoSubRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
            ErrorMessage.MarkdownMissingLink(label)
          )
        );

        expect(polyrepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
            ErrorMessage.MarkdownMissingLink(label)
          )
        );
      });
    });

    it('warns when README.md has a bad standard link reference', async () => {
      expect.hasAssertions();

      patchReadPackageJsonData(
        {
          ['*']: {
            repository: { type: 'git', url: 'https://github.com/user/repo' },
            name: `pkg-${Math.random().toString(16).slice(10)}`
          }
        },
        { replace: false }
      );

      mockedFromMarkdown.mockImplementation(() => ({
        type: 'root',
        children: [
          {
            type: 'definition',
            identifier: 'choose-new-issue',
            label: 'choose-new-issue',
            title: null,
            url: 'https://fake.bad',
            position: {
              start: { line: 968, column: 1, offset: 32219 },
              end: { line: 968, column: 52, offset: 32270 }
            }
          }
        ]
      }));

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadLink(
            'choose-new-issue',
            Constants.markdownReadmeStandardLinks.chooseNewIssue.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownBadLink(
            'choose-new-issue',
            Constants.markdownReadmeStandardLinks.chooseNewIssue.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownBadLink(
            'choose-new-issue',
            Constants.markdownReadmeStandardLinks.chooseNewIssue.url({
              user: 'user',
              repo: 'repo',
              pkgName: ''
            })
          )
        )
      );
    });
  });

  describe('(monorepo-specific checks)', () => {
    it('errors when a sub-root package.json file is missing', async () => {
      expect.hasAssertions();

      const monorepo = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoNonPackageDir.root,
        linkProtectionMarkdownPaths: []
      });

      Fixtures.badMonorepoNonPackageDir.brokenPkgRoots.forEach((pkgRoot) => {
        expect(monorepo.output).toStrictEqual(
          stringContainingErrorMessage(
            'error',
            `${pkgRoot}/package.json`,
            ErrorMessage.MissingFile()
          )
        );
      });
    });

    it('errors when a sub-root package.json file is unparsable', async () => {
      expect.hasAssertions();

      const parse = JSON.parse;
      jest
        .spyOn(JSON, 'parse')
        .mockImplementationOnce((...args) => parse(...args))
        .mockImplementationOnce((...args) => parse(...args))
        .mockImplementationOnce(() => toss(new Error('badness')));

      await expect(
        Linters.runProjectLinter({
          rootDir: Fixtures.goodMonorepo.root,
          linkProtectionMarkdownPaths: []
        })
      ).resolves.toStrictEqual({
        success: false,
        summary: expect.stringContaining('1 error, 0 warnings'),
        output: stringContainingErrorMessage(
          'error',
          `${Fixtures.goodMonorepo.namedPkgMapData[1][1].root}/package.json`,
          ErrorMessage.PackageJsonUnparsable()
        )
      });
    });

    it('errors if two sub-roots share the same name', async () => {
      expect.hasAssertions();

      const monorepo = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoDuplicateName.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepo.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoDuplicateName.root}/pkg/pkg-1`,
          ErrorMessage.DuplicatePackageName(
            'pkg',
            `${Fixtures.badMonorepoDuplicateName.root}/pkg/pkg-2`
          )
        )
      );

      expect(monorepo.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoDuplicateName.root}/pkg/pkg-2`,
          ErrorMessage.DuplicatePackageName(
            'pkg',
            `${Fixtures.badMonorepoDuplicateName.root}/pkg/pkg-1`
          )
        )
      );
    });

    it('errors if two unnamed sub-roots share the same package-id', async () => {
      expect.hasAssertions();

      const monorepo = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoDuplicateId.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepo.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoDuplicateId.root}/packages-1/pkg-1`,
          ErrorMessage.DuplicatePackageId(
            'pkg-1',
            `${Fixtures.badMonorepoDuplicateId.root}/packages-2/pkg-1`
          )
        )
      );

      expect(monorepo.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoDuplicateId.root}/packages-2/pkg-1`,
          ErrorMessage.DuplicatePackageId(
            'pkg-1',
            `${Fixtures.badMonorepoDuplicateId.root}/packages-1/pkg-1`
          )
        )
      );
    });
  });

  describe('(non-sub-root-specific checks)', () => {
    it('warns when missing certain tooling/configuration files', async () => {
      expect.hasAssertions();

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      Constants.repoRootRequiredFiles.forEach((file) => {
        // ? Works when linting a monorepo root
        expect(monorepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepo.root}/${file}`,
            ErrorMessage.MissingFile()
          )
        );

        // ? Does not error when linting a sub-root implicitly
        expect(monorepoRoot.output).not.toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/${file}`,
            ErrorMessage.MissingFile()
          )
        );

        // ? Does not error when linting a sub-root explicitly
        expect(monorepoSubRoot.output).not.toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/${file}`,
            ErrorMessage.MissingFile()
          )
        );

        // ? Works when linting a polyrepo root
        expect(polyrepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badPolyrepo.root}/${file}`,
            ErrorMessage.MissingFile()
          )
        );
      });
    });

    it('warns when missing GitHub tooling/configuration directories', async () => {
      expect.hasAssertions();

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      Constants.repoRootRequiredDirectories.forEach((dir) => {
        // ? Works when linting a monorepo root
        expect(monorepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepo.root}/${dir}`,
            ErrorMessage.MissingDirectory()
          )
        );

        // ? Does not error when linting a sub-root implicitly
        expect(monorepoRoot.output).not.toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/${dir}`,
            ErrorMessage.MissingDirectory()
          )
        );

        // ? Does not error when linting a sub-root explicitly
        expect(monorepoSubRoot.output).not.toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/${dir}`,
            ErrorMessage.MissingDirectory()
          )
        );

        // ? Works when linting a polyrepo root
        expect(polyrepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badPolyrepo.root}/${dir}`,
            ErrorMessage.MissingDirectory()
          )
        );
      });
    });

    it('warns when missing release.config.js unless "private" field is set to "true"', async () => {
      expect.hasAssertions();

      const monorepoRoot1 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot1 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot1 = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      patchReadPackageJsonData(
        {
          ['*']: {
            private: true
          }
        },
        { replace: false }
      );

      const monorepoRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      // ? Works when linting a monorepo root
      expect(monorepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );

      // ? Does not error when linting a sub-root implicitly
      expect(monorepoRoot1.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );

      // ? Does not error when linting a sub-root explicitly
      expect(monorepoSubRoot1.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );

      // ? Works when linting a polyrepo root
      expect(polyrepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );

      // ? Works when linting a monorepo root
      expect(monorepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );

      // ? Does not error when linting a sub-root implicitly
      expect(monorepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );

      // ? Does not error when linting a sub-root explicitly
      expect(monorepoSubRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );

      // ? Works when linting a polyrepo root
      expect(polyrepoRoot2.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/release.config.js`,
          ErrorMessage.MissingFile()
        )
      );
    });

    it('warns when any of several standard Markdown files do not match their blueprints', async () => {
      expect.hasAssertions();

      const readFileActual = fs.readFile;

      // ? Use one file to check that we're not using startsWith
      jest.spyOn(fs, 'readFile').mockImplementation((path, options) => {
        const pathString = path.toString();
        return Promise.resolve(
          pathString.endsWith('/CODE_OF_CONDUCT.md')
            ? blueprints.code_of_conduct + 'additional content'
            : pathString.endsWith('.md') || pathString.endsWith('.yml')
            ? 'fake content'
            : readFileActual(path, options)
        );
      });

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      [
        '.github/CODE_OF_CONDUCT.md',
        '.github/PULL_REQUEST_TEMPLATE.md',
        '.github/ISSUE_TEMPLATE/BUG_REPORT.md',
        '.github/ISSUE_TEMPLATE/FEATURE_REQUEST.md',
        '.github/ISSUE_TEMPLATE/config.yml',
        '.github/dependabot.yml'
      ].forEach((mdFile) => {
        const blueprint = mdFile.split('/').at(-1)?.toLowerCase();

        expect(monorepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepoEmptyMdFiles.root}/${mdFile}`,
            ErrorMessage.MarkdownBlueprintMismatch(`${blueprint}.txt`)
          )
        );

        expect(monorepoSubRoot.output).not.toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepoEmptyMdFiles.root}/${mdFile}`,
            ErrorMessage.MarkdownBlueprintMismatch(`${blueprint}.txt`)
          )
        );

        expect(polyrepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badPolyrepoEmptyMdFiles.root}/${mdFile}`,
            ErrorMessage.MarkdownBlueprintMismatch(`${blueprint}.txt`)
          )
        );
      });
    });

    it('warns when CONTRIBUTING.md, SECURITY.md, or .github/SUPPORT.md do not start with their blueprints', async () => {
      expect.hasAssertions();

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
        linkProtectionMarkdownPaths: []
      });

      ['SECURITY.md', 'CONTRIBUTING.md', '.github/SUPPORT.md'].forEach((mdFile) => {
        const blueprint = mdFile.split('/').at(-1)?.toLowerCase();

        expect(monorepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepoEmptyMdFiles.root}/${mdFile}`,
            ErrorMessage.MarkdownBlueprintMismatch(`${blueprint}.txt`)
          )
        );

        expect(monorepoSubRoot.output).not.toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badMonorepoEmptyMdFiles.root}/${mdFile}`,
            ErrorMessage.MarkdownBlueprintMismatch(`${blueprint}.txt`)
          )
        );

        expect(polyrepoRoot.output).toStrictEqual(
          stringContainingErrorMessage(
            'warn',
            `${Fixtures.badPolyrepoEmptyMdFiles.root}/${mdFile}`,
            ErrorMessage.MarkdownBlueprintMismatch(`${blueprint}.txt`)
          )
        );
      });

      // ? Make sure pathing is working as expected
      expect(monorepoSubRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/SECURITY.md`,
          ErrorMessage.MarkdownBlueprintMismatch('security.md.txt')
        )
      );
    });

    describe('(topmatter/link CONTRIBUTING.md, SECURITY.md, and .github/SUPPORT.md tests)', () => {
      beforeEach(() => {
        const readFileActual = fs.readFile;
        const getAstActual = Utils.getAst;

        // ? The Markdown files are checked against the blueprint initially
        jest.spyOn(fs, 'readFile').mockImplementation((path, options) => {
          const pathString = path.toString();
          return Promise.resolve(
            pathString.endsWith('/SECURITY.md')
              ? blueprints.security
              : pathString.endsWith('/CONTRIBUTING.md')
              ? blueprints.contributing
              : pathString.endsWith('/SUPPORT.md')
              ? blueprints.support
              : readFileActual(path, options)
          );
        });

        // ? The more in-depth checks are done against the ASTs, not the
        // ? readFile contents (above), so these are the primary mock targets
        jest.spyOn(UtilsMdast, 'getAst').mockImplementation((path) => {
          return Promise.resolve(
            path.endsWith('/SECURITY.md')
              ? mockMdastSecurity
              : path.endsWith('/CONTRIBUTING.md')
              ? mockMdastContributing
              : path.endsWith('/SUPPORT.md')
              ? mockMdastSupport
              : getAstActual(path)
          );
        });
      });

      it('warns when topmatter are incorrectly configured', async () => {
        expect.hasAssertions();

        patchReadPackageJsonData({
          ['*']: {
            name: Math.random().toString(16).slice(2),
            repository: { type: 'git', url: 'https://github.com/user/repo' }
          }
        });

        const monorepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        const polyrepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        [
          [monorepoRoot, Fixtures.badMonorepoEmptyMdFiles] as const,
          [polyrepoRoot, Fixtures.badPolyrepoEmptyMdFiles] as const
        ].forEach(([output, fixture]) => {
          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/SECURITY.md`,
              ErrorMessage.MarkdownBadTopmatterImageRefDefUrl(
                'badge-security',
                Constants.markdownSecurityStandardTopmatter.vulnerabilities.url({
                  user: 'user',
                  repo: 'repo',
                  pkgName: ''
                })
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterImageRefDefUrl(
                'badge-issue-resolution',
                Constants.markdownSupportStandardTopmatter.issuesResolution.url({
                  user: 'user',
                  repo: 'repo',
                  pkgName: ''
                })
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterImageRefDefUrl(
                'badge-issue-percentage',
                Constants.markdownSupportStandardTopmatter.issuesPercentage.url({
                  user: 'user',
                  repo: 'repo',
                  pkgName: ''
                })
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/SECURITY.md`,
              ErrorMessage.MarkdownBadTopmatterImageRefDefTitle(
                'badge-security',
                'Number of vulnerabilities (scanned by Snyk)'
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterImageRefDefTitle(
                'badge-issue-resolution',
                'Average time to resolve an issue'
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterImageRefDefTitle(
                'badge-issue-percentage',
                'Open issues as a percentage of all issues'
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/SECURITY.md`,
              ErrorMessage.MarkdownBadTopmatterLinkRefDefUrl(
                'link-security',
                Constants.markdownSecurityStandardTopmatter.vulnerabilities.link.url({
                  user: 'user',
                  repo: 'repo',
                  pkgName: ''
                })
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterLinkRefDefUrl(
                'link-issue-resolution',
                Constants.markdownSupportStandardTopmatter.issuesResolution.link.url({
                  user: 'user',
                  repo: 'repo',
                  pkgName: ''
                })
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterLinkRefDefUrl(
                'link-issue-percentage',
                Constants.markdownSupportStandardTopmatter.issuesPercentage.link.url({
                  user: 'user',
                  repo: 'repo',
                  pkgName: ''
                })
              )
            )
          );
        });
      });

      it('warns when topmatter are missing', async () => {
        expect.hasAssertions();

        jest.spyOn(UtilsMdast, 'getAst').mockImplementation(() =>
          Promise.resolve({
            type: 'root',
            children: []
          })
        );

        patchReadPackageJsonData({
          ['*']: {
            name: Math.random().toString(16).slice(2),
            repository: { type: 'git', url: 'https://github.com/user/repo' }
          }
        });

        const monorepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        const polyrepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        [
          [monorepoRoot, Fixtures.badMonorepoEmptyMdFiles] as const,
          [polyrepoRoot, Fixtures.badPolyrepoEmptyMdFiles] as const
        ].forEach(([output, fixture]) => {
          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/SECURITY.md`,
              ErrorMessage.MarkdownBadTopmatterMissingImageRefDef('badge-security')
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterMissingImageRefDef(
                'badge-issue-resolution'
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterMissingImageRefDef(
                'badge-issue-percentage'
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/SECURITY.md`,
              ErrorMessage.MarkdownBadTopmatterMissingLinkRefDef('link-security')
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterMissingLinkRefDef('link-issue-resolution')
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadTopmatterMissingLinkRefDef('link-issue-percentage')
            )
          );
        });
      });

      it('warns when standard links are incorrectly configured', async () => {
        expect.hasAssertions();

        patchReadPackageJsonData({
          ['*']: {
            name: Math.random().toString(16).slice(2),
            repository: { type: 'git', url: 'https://github.com/user/repo' }
          }
        });

        const monorepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        const polyrepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        [
          [monorepoRoot, Fixtures.badMonorepoEmptyMdFiles] as const,
          [polyrepoRoot, Fixtures.badPolyrepoEmptyMdFiles] as const
        ].forEach(([output, fixture]) => {
          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/SECURITY.md`,
              ErrorMessage.MarkdownBadLink(
                'security-mailto',
                Constants.markdownSecurityStandardLinks.securityMailTo.url({
                  repo: 'repo',
                  user: 'user',
                  pkgName: ''
                })
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownBadLink(
                'github-blog',
                Constants.markdownSupportStandardLinks.githubBlog.url({
                  repo: 'repo',
                  user: 'user',
                  pkgName: ''
                })
              )
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/CONTRIBUTING.md`,
              ErrorMessage.MarkdownBadLink(
                'gha-ci',
                Constants.markdownContributingStandardLinks.ghaCi.url({
                  repo: 'repo',
                  user: 'user',
                  pkgName: ''
                })
              )
            )
          );
        });
      });

      it('warns when standard links are missing', async () => {
        expect.hasAssertions();

        jest.spyOn(UtilsMdast, 'getAst').mockImplementation(() =>
          Promise.resolve({
            type: 'root',
            children: []
          })
        );

        patchReadPackageJsonData({
          ['*']: {
            name: Math.random().toString(16).slice(2),
            repository: { type: 'git', url: 'https://github.com/user/repo' }
          }
        });

        const monorepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        const polyrepoRoot = await Linters.runProjectLinter({
          rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        [
          [monorepoRoot, Fixtures.badMonorepoEmptyMdFiles] as const,
          [polyrepoRoot, Fixtures.badPolyrepoEmptyMdFiles] as const
        ].forEach(([output, fixture]) => {
          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/SECURITY.md`,
              ErrorMessage.MarkdownMissingLink('security-mailto')
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/.github/SUPPORT.md`,
              ErrorMessage.MarkdownMissingLink('github-blog')
            )
          );

          expect(output.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${fixture.root}/CONTRIBUTING.md`,
              ErrorMessage.MarkdownMissingLink('gha-ci')
            )
          );
        });
      });

      it('warns when missing repository url and/or name while performing checks', async () => {
        expect.hasAssertions();

        patchReadPackageJsonData({
          [Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root]: {
            repository: 'https://github.com/user/repo'
          },
          [Fixtures.badPolyrepoEmptyMdFiles.root]: {
            repository: { type: 'git', url: 'https://github.com/user/repo' }
          }
        });

        const monorepoRoot1 = await Linters.runProjectLinter({
          rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        const polyrepoRoot1 = await Linters.runProjectLinter({
          rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        patchReadPackageJsonData({
          ['*']: {
            name: Math.random().toString(16).slice(2),
            repository: 'https://github.com/user/repo'
          },
          [Fixtures.badPolyrepoEmptyMdFiles.root]: {
            repository: { type: 'git', url: 'https://github.com/user/repo' }
          }
        });

        const monorepoRoot2 = await Linters.runProjectLinter({
          rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        const polyrepoRoot2 = await Linters.runProjectLinter({
          rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
          linkProtectionMarkdownPaths: []
        });

        ['SECURITY.md', 'CONTRIBUTING.md', '.github/SUPPORT.md'].forEach((mdFile) => {
          expect(monorepoRoot1.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${Fixtures.badMonorepoEmptyMdFiles.root}/${mdFile}`,
              ErrorMessage.PackageJsonMissingKeysCheckSkipped()
            )
          );

          expect(polyrepoRoot1.output).toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${Fixtures.badPolyrepoEmptyMdFiles.root}/${mdFile}`,
              ErrorMessage.PackageJsonMissingKeysCheckSkipped()
            )
          );

          expect(monorepoRoot2.output).not.toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${Fixtures.badMonorepoEmptyMdFiles.root}/${mdFile}`,
              ErrorMessage.PackageJsonMissingKeysCheckSkipped()
            )
          );

          expect(polyrepoRoot2.output).not.toStrictEqual(
            stringContainingErrorMessage(
              'warn',
              `${Fixtures.badPolyrepoEmptyMdFiles.root}/${mdFile}`,
              ErrorMessage.PackageJsonMissingKeysCheckSkipped()
            )
          );
        });
      });
    });
  });

  describe('(monorepo-root-specific checks)', () => {
    it('warns when package.json "name" field is missing even when private', async () => {
      expect.hasAssertions();

      patchReadPackageJsonData({
        ['*']: {
          private: true
        }
      });

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      // ? Works when linting a monorepo root
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey('name')
        )
      );

      // ? Does not error when linting a sub-root implicitly
      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey('name')
        )
      );

      // ? Does not error when linting a sub-root explicitly
      expect(monorepoSubRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey('name')
        )
      );

      // ? Does not when linting a polyrepo root
      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey('name')
        )
      );
    });

    it('warns when package.json is missing "private" field or when "private" is not "true"', async () => {
      expect.hasAssertions();

      const monorepoRoot1 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      patchReadPackageJsonData({
        ['*']: {
          private: false
        }
      });

      const monorepoRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot1.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey('private')
        )
      );

      expect(monorepoRoot2.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingValue('private', 'true')
        )
      );
    });

    it('warns when package.json contains "dependencies" field unless a next.config.js file exists', async () => {
      expect.hasAssertions();

      patchReadPackageJsonData({
        ['*']: {
          dependencies: {
            async: '^1.2.3'
          }
        }
      });

      const badMonorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const goodMonorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoNextjsProject.root,
        linkProtectionMarkdownPaths: []
      });

      expect(badMonorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('dependencies')
        )
      );

      expect(goodMonorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.goodMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('dependencies')
        )
      );
    });

    it('warns when package.json contains non-whitelisted "version" fields unless a next.config.js file exists', async () => {
      expect.hasAssertions();

      patchReadPackageJsonData({
        [Fixtures.badMonorepo.root]: {
          version: '0.0.0-monorepo'
        }
      });

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      patchReadPackageJsonData({
        ['*']: {
          version: '1.2.3'
        }
      });

      const monorepoRoot2 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoRoot3 = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepoNextjsProject.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('version')
        )
      );

      expect(monorepoRoot2.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('version')
        )
      );

      expect(monorepoRoot3.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepoNextjsProject.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('version')
        )
      );

      expect(monorepoSubRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('version')
        )
      );

      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.goodPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('version')
        )
      );
    });

    it('correctly detects, collates, and counts warnings and errors across entire monorepo', async () => {
      expect.hasAssertions();
      // TODO: monorepo (amalgum) but NOT fail on ok sub-root
      // TODO: Use snapshots + error/warning count
      // TODO: 0 warnings/errors on good monorepo
    });
  });

  describe('(sub-root-specific checks)', () => {
    it(`warns when package.json "config['plugin-build'].codecov.flag" is missing`, async () => {
      expect.hasAssertions();

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey("config['plugin-build'].codecov.flag")
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonMissingKey("config['plugin-build'].codecov.flag")
        )
      );

      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonMissingKey("config['plugin-build'].codecov.flag")
        )
      );
    });

    it('errors when sub-root code imports another sub-root without also listing it under "dependency" in package.json (i.e. an unlisted cross-dependency)', async () => {
      expect.hasAssertions();
      // TODO: sub-root but does NOT fail on polyrepo. However, does NOT error
      // TODO: on unlisted self-referential imports

      // TODO: Check for PackageJsonMissingExportCheckSkipped?
    });

    it('errors when sub-root code imports another sub-root without without using the pkgverse alias', async () => {
      expect.hasAssertions();
      // TODO: Check for PackageJsonMissingExportCheckSkipped?
    });

    it('warns when package.json contains "devDependencies" field', async () => {
      expect.hasAssertions();
      // TODO: sub-root but does NOT fail on monorepo root or polyrepo

      patchReadPackageJsonData({
        [Fixtures.badMonorepo.root]: {
          devDependencies: {
            async: '1.2.3'
          }
        }
      });

      const monorepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.root,
        linkProtectionMarkdownPaths: []
      });

      const monorepoSubRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badMonorepo.unnamedPkgMapData[0][1].root,
        linkProtectionMarkdownPaths: []
      });

      const polyrepoRoot = await Linters.runProjectLinter({
        rootDir: Fixtures.badPolyrepo.root,
        linkProtectionMarkdownPaths: []
      });

      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('devDependencies')
        )
      );

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('devDependencies')
        )
      );

      expect(monorepoSubRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.badMonorepo.unnamedPkgMapData[0][1].root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('devDependencies')
        )
      );

      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'warn',
          `${Fixtures.goodPolyrepo.root}/package.json`,
          ErrorMessage.PackageJsonIllegalKey('devDependencies')
        )
      );
    });

    it('correctly detects, collates, and counts warnings and errors from a single sub-root', async () => {
      expect.hasAssertions();
      // TODO: monorepo (amalgum) but NOT fail on ok sub-root
      // TODO: Use snapshots + error/warning count
      // TODO: 0 warnings/errors on good monorepo
    });
  });

  it('only executes certain checks when in pre-push mode', async () => {
    expect.hasAssertions();

    const actualReadFile = fs.readFile;
    const commits: string[] = [];

    mockedRun.mockImplementation(makeMockGitCommit(commits));

    jest
      .spyOn(fs, 'readFile')
      .mockImplementation((path, opts) =>
        path.toString().endsWith('.md') ? getBadMarkdown() : actualReadFile(path, opts)
      );

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob],
      mode: 'pre-push'
    });

    commits.forEach((commit) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `git commit ${commit}`,
          ErrorMessage.CommitNeedsFixup()
        )
      );
    });

    commits.splice(0, commits.length);

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob],
      mode: 'pre-push'
    });

    commits.forEach((commit) => {
      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `git commit ${commit}`,
          ErrorMessage.CommitNeedsFixup()
        )
      );
    });

    getBadLines().forEach((badLine) => {
      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/CONTRIBUTING.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/RANDOM.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );
    });
  });

  it('only executes certain checks when in link protection mode', async () => {
    expect.hasAssertions();

    const actualReadFile = fs.readFile;
    const commits: string[] = [];

    mockedRun.mockImplementation(makeMockGitCommit(commits));

    jest
      .spyOn(fs, 'readFile')
      .mockImplementation((path, opts) =>
        path.toString().endsWith('.md') ? getBadMarkdown() : actualReadFile(path, opts)
      );

    const monorepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badMonorepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob],
      mode: 'link-protection'
    });

    commits.forEach((commit) => {
      expect(monorepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `git commit ${commit}`,
          ErrorMessage.CommitNeedsFixup()
        )
      );
    });

    commits.splice(0, commits.length);

    const polyrepoRoot = await Linters.runProjectLinter({
      rootDir: Fixtures.badPolyrepoEmptyMdFiles.root,
      linkProtectionMarkdownPaths: [Constants.defaultMarkdownGlob],
      mode: 'link-protection'
    });

    commits.forEach((commit) => {
      expect(polyrepoRoot.output).not.toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `git commit ${commit}`,
          ErrorMessage.CommitNeedsFixup()
        )
      );
    });

    getBadLines().forEach((badLine) => {
      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.root}/CONTRIBUTING.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(monorepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badMonorepoEmptyMdFiles.unnamedPkgMapData[0][1].root}/RANDOM.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );

      expect(polyrepoRoot.output).toStrictEqual(
        stringContainingErrorMessage(
          'error',
          `${Fixtures.badPolyrepoEmptyMdFiles.root}/README.md`,
          ErrorMessage.MarkdownDisabledLink(badLine)
        )
      );
    });
  });

  it('correctly detects, collates, and counts warnings and errors in polyrepo', async () => {
    expect.hasAssertions();
    // TODO: polyrepo (amalgum)
    // TODO: Use snapshots + error/warning count
    // TODO: 0 warnings/errors on good polyrepo
  });
});

describe('::runTypescriptLinter', () => {
  it('correctly parses different combinations of error and warning messages', async () => {
    expect.hasAssertions();
    // TODO: Including no message and non-parsable message + success == false
  });
});

describe('::runEslintLinter', () => {
  it('correctly parses different combinations of error and warning messages', async () => {
    expect.hasAssertions();
    // TODO: Including no message and non-parsable message + success == false
  });
});

describe('::runRemarkLinter', () => {
  it('correctly parses different combinations of error and warning messages', async () => {
    expect.hasAssertions();
    // TODO: Including no message and non-parsable message + success == false
  });
});
